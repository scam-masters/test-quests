{
    "exercises": {
        "mission_1": {
            "kind": "unit",
            "blocks": [
                "A single scenario to test a specific function of the website.",
                "Checking if the output matches the expected result.",
                "A collection of several test cases.",
                "A tool used to execute test cases.",
                "Setting up a simulated user environment before running each test."
            ],
            "threshold": 100,
            "learning": {
                "exerciseLink": "/exercise/1",
                "learningLink": "/learning/1",
                "resourceLink": "https://it.wikipedia.org/wiki/Unit_testing",
                "content": "<center><h1 className=\"p-4 text-center\"><strong>Welcome to Mission Number 1 <br/> Master the Basics of Unit Testing</strong></h1> </center> <br /> <h2 className=\"mb-4 text-center\"><strong>Introduction to Unit Testing</strong></h2> <p><strong>What is Unit Testing?</strong></p> <p> Unit testing is a fundamental practice in software development that involves testing individual units or components     of a program to ensure they function as expected. A \"unit\" is the smallest testable part of an application, such as     a function, method, or class. </p> <br> <p><strong>Why Unit Testing?</strong></p> <ul>     <li><strong>Early Detection of Bugs:</strong> Unit testing helps identify and fix bugs early in the development         process, preventing issues from escalating to higher levels.</li>     <li><strong>Code Stability:</strong> It ensures that changes made to the codebase do not negatively impact existing         functionality.</li>     <li><strong>Documentation:</strong> Unit tests serve as living documentation, providing insights into the expected         behavior of components.</li> </ul> <br> <h2 className=\"mb-4 text-center\"><strong>Key Concepts in Unit Testing</strong></h2> <p><strong>Test Case</strong></p> <p> A test case is a set of conditions or variables under which a tester will determine whether a system under test     satisfies requirements or works correctly. It represents a single scenario to test a specific function. </p>  <br> <h2 className=\"mb-4\"><strong>Putting Concepts into Practice</strong></h2> <p> Now, let's apply these concepts to real-world scenarios related to a basic website. In the upcoming exercise, you'll     have the opportunity to match these fundamental unit testing concepts with scenarios specific to testing a website's     functionality. </p> <br> <h3 className=\"mb-2\"><strong>Exercise Overview:</strong></h3> <ul>     <li><strong>Scenario 1:</strong> Match each basic unit testing concept with the correct scenario for a simple         website.</li>     <li><strong>Scenario 2:</strong> Drag and drop each concept to its corresponding match in the context of a basic         website.</li> </ul> <br> <h3 className=\"mb-2\"><strong>Matches:</strong></h3> <ul>     <li><strong>Concept 1 - Test Case:</strong> Match with <strong>Scenario C - A single scenario to test a specific             function.</strong></li>  </ul> <br> <h2 className=\"mb-4\"><strong>Get Ready to Dive In!</strong></h2> <p> Now that you have a solid understanding of the basics of unit testing, it's time to put your knowledge into action.     Dive into the exercise, have fun, and master the art of unit testing! </p>"
            },
            "type": "mm",
            "explanation": "    <h2><strong>Overview:</strong></h2><br>     <p>In this beginner-level exercise, students will match fundamental unit testing concepts with simple scenarios related to a basic website. The goal is to introduce the core ideas of unit testing in a very easy-to-understand format.</p>      <br><br><h2><strong>Instructions:</strong></h2> <br>    <p>Match each basic unit testing concept in the left column with the correct scenario for a simple website in the right column. Drag and drop each concept to its corresponding match.</p>",
            "points": 50,
            "difficulty": "easy",
            "solution": [
                "Test Case",
                "Assertion",
                "Test Suite",
                "Test Runner",
                "Test Fixture"
            ],
            "storyline": "python",
            "options": [
                "1",
                "2",
                "3",
                "4",
                "5"
            ],
            "name": "Unit Test: Mastering Basics",
            "text": ""
        },
        "mission_10": {
            "difficulty": "hard",
            "solution": [
                "webdriver",
                "Chrome",
                "ChromeDriverManager()",
                "install()",
                "quit()",
                "maximize_window",
                "find_element_by_name",
                "\"webdrivermanager\"",
                "find_element_by_link_text",
                "\"Google Images\"",
                "\"I'm Feeling Lucky\"",
                "Confusion Statement 1",
                "Confusion Statement 2",
                "Confusion Statement 3",
                "Confusion Statement 4"
            ],
            "kind": "unit",
            "blocks": [
                "class TestGoogle:<br> <br> &emsp;@classmethod<br> &emsp;@pytest.fixture(scope=\"class\", autouse=True)<br> &emsp;def setup(cls, request):<br> &emsp;&emsp;# Set up WebDriver using Chrome with Webdriver Manager<br><br> &emsp;&emsp;cls.driver = [",
                "",
                "].[",
                "",
                "]([",
                "",
                "]().[",
                "",
                "]())<br>",
                "&emsp;&emsp;yield<br>",
                "&emsp;&emsp;cls.driver.[",
                "",
                "]()<br>",
                "<br> &emsp;@classmethod<br> &emsp;@pytest.fixture(scope=\"class\")<br> &emsp;def additional_setup(cls, request):<br> &emsp;&emsp;# Maximize the browser window before each test<br> &emsp;&emsp;cls.driver.[",
                "",
                "]()<br>",
                "<br> &emsp;@classmethod<br> &emsp;@pytest.fixture(scope=\"class\")<br> &emsp;def additional_setup(cls, request):<br> &emsp;&emsp;# Maximize the browser window before each test<br> &emsp;&emsp;cls.driver.[",
                "",
                "]()<br>",
                "<br> &emsp;def test_search(self):<br> &emsp;&emsp;self.driver.get(\"https://www.google.com\")<br> &emsp;&emsp;search_box = self.driver.[",
                "a",
                "",
                "](\"q\")<br> &emsp;&emsp;search_box.send_keys(\"Webdriver Manager\")<br> &emsp;&emsp;search_box.send_keys(Keys.RETURN)<br> &emsp;&emsp;assert [",
                "",
                "] in self.driver.title<br> <br> &emsp;def test_images_search(self):<br> &emsp;&emsp;self.driver.get(\"https://www.google.com\")<br> &emsp;&emsp;images_link = self.driver.[",
                "",
                "](\"Images\")<br> &emsp;&emsp;images_link.click()<br> &emsp;&emsp;assert [",
                "",
                "] in self.driver.title<br> <br> &emsp;def test_lucky_button(self):<br> &emsp;&emsp;self.driver.get(\"https://www.google.com\")<br> &emsp;&emsp;lucky_button = self.driver.find_element_by_name(\"btnI\")<br> &emsp;&emsp;lucky_button.click()<br> &emsp;&emsp;assert [",
                "",
                "] in self.driver.title<br>"
            ],
            "storyline": "python",
            "name": "WebDriver Manager",
            "threshold": 75,
            "learning": {
                "exerciseLink": "/exercise/10",
                "learningLink": "/learning/10",
                "resourceLink": "https://pypi.org/project/webdriver-manager/",
                "content": "   <center><h1><b>Welcome to Mission 10</b> </h1>     <h2>About Webdriver Manager</h2>     </center>     <br><p>         Webdriver Manager is a Python library designed to streamline the management of binary drivers essential for automating web browsers using Selenium. It aims to simplify the often cumbersome process of downloading, installing, and configuring these drivers across different platforms and browser versions.     </p><br>     <p>         The core functionality of Webdriver Manager revolves around providing an easy-to-use interface for developers to handle the setup of browser drivers effortlessly. It supports a variety of popular web browsers such as Chrome, Firefox, Edge, Opera, Brave, and Internet Explorer, ensuring compatibility with Selenium versions 3.x and 4.x.     </p><br>     <p>         Prior to the introduction of Webdriver Manager, developers had to manually download the appropriate driver binaries, extract them to a specific location, and set up environment variables or specify paths within their codebase. This process was not only time-consuming but also prone to errors, especially when managing multiple browser versions or operating systems.     </p><br>     <p>         With Webdriver Manager, developers can now install the manager itself using Python package manager (pip), and then seamlessly integrate it into their Selenium automation scripts. The library takes care of downloading the necessary driver binaries, managing their versions, and ensuring compatibility with the installed browser versions.     </p><br>     <p>         Furthermore, Webdriver Manager offers various configuration options to cater to different use cases and environments. Developers can customize settings such as cache management, SSL verification, browser version specification, and even use custom HTTP clients for more advanced scenarios.     </p><br>     <p>         In summary, Webdriver Manager serves as a vital tool in the toolkit of Python developers engaged in web automation, offering a convenient and reliable solution for managing browser drivers and streamlining the Selenium testing process.     </p>"
            },
            "type": "dnd",
            "explanation": "<p>Objective:<br> The objective of this exercise is to implement automated tests using Selenium and PyTest to interact with the Google search page and verify specific functionalities.<br><br> </p> <p>Test Cases:<br> 1. <strong>Test Search Functionality:</strong><br>    - Open the Google homepage.<br>    - Enter \"Webdriver Manager\" into the search box.<br>    - Press Enter.<br>    - Verify that the search results page title contains \"webdrivermanager\".<br> <br> 2. <strong>Test Images Search:</strong><br>    - Open the Google homepage.<br>    - Click on the \"Images\" link.<br>    - Verify that the page title changes to \"Google Images\".<br> <br> 3. <strong>Test \"I'm Feeling Lucky\" Button:</strong><br>    - Open the Google homepage.<br>    - Click on the \"I'm Feeling Lucky\" button.<br>    - Verify that the page title changes to \"I'm Feeling Lucky\".<br> <br> Provided Code:<br> - The provided code contains a PyTest test class named <code>TestGoogle</code>.<br> - It includes fixtures to set up and tear down the WebDriver session, as well as additional setup to maximize the browser window.<br> - Three test methods are defined to execute the test cases mentioned above: <code>test_search</code>, <code>test_images_search</code>, and <code>test_lucky_button</code>.<br> <br> Missing Parts:<br> - The code provided has certain parts missing, denoted by placeholders such as <code>[---------]</code> and <code>[----------------------]</code>.<br> - These placeholders need to be replaced with appropriate Selenium WebDriver methods or attributes to complete the test automation code.<br> <br> Solution:<br> - The solution code provided fills in the missing parts with the correct WebDriver methods and attributes to interact with the Google search page and perform the desired actions.<br> - It completes the test automation code for the provided test cases, allowing the tests to execute successfully and verify the expected behavior of the Google search page.<br> <br> Execution and Verification:<br> - To execute the test cases, the complete test automation code (including the solution) needs to be run using PyTest.<br> - The tests will open a Chrome browser, navigate to the Google homepage, perform the specified actions, and verify the expected outcomes.<br> - Upon execution, the test results will indicate whether the test cases pass or fail based on the assertions defined in the test methods.<br> <br> Learning Outcome:<br> - By completing this exercise, learners will gain hands-on experience in writing automated tests using Selenium and PyTest to interact with web pages, perform actions, and verify expected outcomes.<br> - Learners will also become familiar with common Selenium WebDriver methods for locating elements and performing actions such as clicking links and entering text into input fields.<br> </p>",
            "points": 150
        },
        "mission_11": {
            "difficulty": "hard",
            "storyline": "python",
            "name": "Semantic and Syntax Errors on pytest",
            "threshold": 90,
            "learning": {
                "exerciseLink": "/exercise/11",
                "learningLink": "/learning/11",
                "content": "    <center><h1><b>Welcome to Mission 11</b> </h1>     <h2>About Understanding Semantic and Syntax Bugs using pytest</h2></center>     <p>         Semantic and Syntax bugs are common issues encountered during software development. It's crucial to distinguish between them to effectively debug and maintain code.     </p>     <br>     <p>         Semantic bugs occur when the logic of the program is flawed, leading to unexpected behavior. These bugs may not result in syntax errors but can cause incorrect program output or undesired outcomes. Semantic bugs are often harder to detect than syntax bugs because they involve understanding the intended functionality of the code. Examples of semantic bugs include miscalculations, incorrect conditional statements, and improper data handling.     </p>     <br>     <p>         Syntax bugs, on the other hand, are errors in the structure or grammar of the code. These bugs violate the rules of the programming language, causing the interpreter or compiler to raise errors. Syntax bugs are usually easier to identify and fix compared to semantic bugs because they are detected by the compiler or interpreter during the code compilation or execution process. Common syntax bugs include missing semicolons, mismatched parentheses, and misspelled keywords.     </p>     <br>     <h3>Risks and Impact:</h3>     <p>         Semantic bugs can have significant consequences, such as incorrect computation results, security vulnerabilities, or system crashes. These bugs can lead to data corruption, loss of user trust, and financial losses for organizations. Syntax bugs typically prevent the code from executing altogether, resulting in immediate errors during compilation or runtime. While less severe than semantic bugs, syntax bugs can still disrupt development workflow and delay project timelines.     </p>     <br>     <h3>Preventing and Resolving Bugs:</h3>     <p>         To prevent semantic bugs, developers should thoroughly understand the requirements and specifications of the software and conduct rigorous testing. Code reviews, unit testing, and integration testing are essential for identifying and addressing semantic bugs early in the development lifecycle. Debugging semantic bugs involves analyzing the program's behavior, identifying discrepancies between expected and actual outcomes, and implementing corrective measures.     </p>     <br>     <p>         Syntax bugs can be avoided by adhering to the syntax rules of the programming language, using linting tools, and paying attention to compiler or interpreter error messages. Code editors with syntax highlighting and auto-completion features can also help prevent syntax errors during development. Debugging syntax bugs involves analyzing the code for syntax errors indicated by error messages and correcting them accordingly using code editors or integrated development environments (IDEs).     </p>",
                "resouceLink": "https://www.honeybadger.io/blog/beginners-guide-to-software-testing-in-python/"
            },
            "text": "class TestBook:\n  @pytest.mark.parametrize(\"title, author, pages\",\n\t\t\t\t\t\t [(\"Harry Potter\", \"J.K. Rowling\", 500),\n\t\t\t\t\t\t  (\"The Great Gatsby\", \"F. Scott Fitzgerald\", 218),\n\t\t\t\t\t\t  (\"To Kill a Mockingbird\", \"Harper Lee\", 281)])\n  def test_read_book(self, title, author, pages):\n      book = Book(title, author, pages)\n      assert Book.read_book() == f\"Reading {title} by {author}\"\n\n  def test_flip_pages_valid(self, title, author, pages, page_number):\n      book = Book(title, author, pages)\n      assert book.flip_pages(page_number) == f\"Flipping to page {author} of {title}\"\n\n  def test_invalid_title(self):\n      book = Book(\"J.K. Rowling\", 500)\n      assert book.read_book() == \"Reading J.K. Rowling\"\n\n  def test_valid_read(self, subject):\n\t  book = Book(\"Harry Potter\", \"J.K. Rowling\", 500)\n\t  assert book.read_book(subject) == \"Reading J.K. Rowling\"\n\t\n  def test_flip_pages_invalid(self, title, author, pages):\n      book = Book(author, title, pages)\n      with pytest.raises(AssertionError):\n          book.flip_pages(1000)",
            "type": "debug",
            "explanation": "You have a class <code>Book:<br><br>class Book:<br><br>&emsp;def __init__(self, title, author, pages):<br>&emsp;&emsp;self.title = title<br>&emsp;&emsp;self.author = author<br>&emsp;&emsp;self.pages = pages<br><br>&emsp;def read_book(self):<br>&emsp;&emsp;return f\"Reading {self.title} by {self.author}\"<br><br>&emsp;def flip_pages(self, page_number):<br>&emsp;&emsp;if page_number > self.pages:<br>&emsp;&emsp;&emsp;raise ValueError(\"Page number exceeds total pages of the book.\")<br>&emsp;&emsp;return f\"Flipping to page {page_number} of {self.title}\"</code><br><br> Consider the pytest class on the right, which is importing and using the <code>Book</code> class to test it.<br>Your goal is to spot bugs in the code of the tests.",
            "points": 150,
            "selectables": [
                "122-170",
                "290-316",
                "536-576",
                "623-648",
                "655-678",
                "799-829",
                "923-956",
                "963-998",
                "1008-1030"
            ],
            "solution": [
                true,
                true,
                false,
                false,
                true,
                false,
                false,
                false,
                true
            ]
        },
        "mission_12": {
            "difficulty": "hard",
            "kind": "e2e",
            "storyline": "python",
            "name": "Slow Calculator",
            "questions": {
                "Considering that the calculator needs 5 seconds to get the results, how can I make sure that the result is displayed?": {
                    "WebDriverWait(self.driver, 6).until(EC.text_to_be_present_in_element(result, '10'))": true,
                    "assert result.text == 10": false,
                    "assert wait_until(lambda: result.text == '10', timeout=6)": true,
                    "sleep(6); assert result.text == 10": true,
                    "driver.implicitly_wait(2)": true
                },
                "How can I retrieve the result display screen?": {
                    "self.driver.findElement(By.xpath('//*[@id='calculator']/div[1]/div'))": true,
                    "driver.find_element(By.ID, 'screen')": false,
                    "self.driver.findElement(By.xpath('/html/body/main/div/div[4]/div/div/div[1]/div’))": true,
                    "driver.find_element(By.CLASS_NAME, 'screen')": true
                }
            },
            "threshold": "80",
            "learning": {
                "exerciseLink": "/exercise/12",
                "learningLink": "/learning/12",
                "resourceLink": "https://www.selenium.dev/documentation/webdriver/waits/",
                "content": "<center>   <h1><b>Welcome to Mission 12</b></h1>   <h2><b>About Understanding Testing for a Slow Calculator</b></h2> </center> <p>   In this mission, you will learn about testing a slow calculator that   introduces a 5-second delay before displaying results. Testing such a   calculator involves understanding its behavior under various conditions and   ensuring accurate results despite the delay. </p> <br /> <h3 style=\"text-align: center\"><b>Testing Objectives:</b></h3> <ul style=\"list-style-type: disc; padding-left: 20px\">   <li>     Ensuring accurate computation despite the delay introduced by the     calculator.   </li>   <li>     Verifying that the calculator displays results after the expected waiting     period.   </li>   <li>     Testing the functionality of the calculator's operations (addition,     subtraction, multiplication, division) under delay conditions.   </li>   <li>     Validating the responsiveness of the calculator's interface during the     waiting period.   </li> </ul> <br /> <h3 style=\"text-align: center\"><b>Types of Tests:</b></h3> <ul style=\"list-style-type: disc; padding-left: 20px\">   <li>     Functional Testing: Verifies that each operation (addition, subtraction,     multiplication, division) produces correct results despite the delay.   </li>   <li>     Integration Testing: Ensures seamless interaction between different     components of the calculator, including the display and computation modules.   </li>   <li>     User Interface Testing: Checks the responsiveness of the calculator's     interface during the waiting period to ensure a smooth user experience.   </li>   <li>     Performance Testing: Measures the calculator's response time and resource     utilization under delay conditions to assess its efficiency.   </li> </ul> <br /> <h3 style=\"text-align: center\"><b>Challenges:</b></h3> <ul style=\"list-style-type: disc; padding-left: 20px\">   <li>     Managing expectations: Users may expect immediate results, so it's crucial     to communicate the delay effectively.   </li>   <li>     Handling concurrency: Testing multiple operations simultaneously to simulate     real-world usage scenarios.   </li>   <li>     Ensuring accuracy: Verifying that the delayed results are correct and     consistent with the expected outcomes.   </li>   <li>     Optimizing performance: Identifying bottlenecks and optimizing the     calculator's performance to minimize the impact of the delay.   </li> </ul> <br /> <h3 style=\"text-align: center\"><b>Conclusion:</b></h3> <p>   Testing a slow calculator requires a comprehensive approach to ensure accurate   results and a seamless user experience despite the delay. By understanding the   behavior of the calculator and applying appropriate testing techniques, you   can identify and resolve any issues effectively. </p>"
            },
            "embedding": "https://bonigarcia.dev/selenium-webdriver-java/slow-calculator.html",
            "text": "class SlowCalculatorTest(): \n\tdef setUp(self): \n\t  self.driver = webdriver.Chrome() \n\t  self.driver.get(\"https://bonigarcia.dev/selenium-webdriver-java/slow-calculator.html\") \n\n\tdef test_sum(self): \n\t\tbutton_five = self.driver.findElement(By.xpath('//*[@id=\"calculator\"]/div[2]/span[6]')) \n\t\tbutton_sum = self.driver.findElement(By.xpath('//*[@id=\"calculator\"]/div[2]/span[4]')) \n\t\tbutton_equals = self.driver.findElement(By.xpath('//*[@id=\"calculator\"]/div[2]/span[15]')) \n\t\tresult = {/* insert your first answer here */}      \n\n\t\tbutton_five.click() \n\t\tbutton_sum.click() \n\t\tbutton_five.click()     \n\t\tbutton_equals.click()      \n\n\t\t{/* wait until the result is not displayed */}\n\n",
            "type": "ms",
            "explanation": "",
            "points": "150"
        },
        "mission_13": {
            "kind": "unit",
            "storyline": "java",
            "questions": {},
            "name": "Coming soon...",
            "threshold": "100",
            "learning": {
                "exerciseLink": "",
                "learningLink": "",
                "resourceLink": "",
                "content": ""
            },
            "type": "ms",
            "explanation": "",
            "points": "50",
            "difficulty": "easy"
        },
        "mission_2": {
            "difficulty": "easy",
            "kind": "security",
            "storyline": "python",
            "name": "Login Bypass",
            "threshold": 100,
            "learning": {
                "exerciseLink": "/exercise/2",
                "learningLink": "/learning/2",
                "resourceLink": "https://owasp.org/www-community/attacks/SQL_Injection",
                "content": " <center><p><strong>Welcome to Mission Number 2</strong></p> <p>It's time to dive into SQL injection; prepare for the challenge...</p></center> <br>  <p><strong>Understanding SQL Injection (Login Bypass)</strong></p> <p>SQL Injection is a malicious technique that attackers use to exploit vulnerabilities in a web application's database layer. In the context of login forms, it allows unauthorized access by manipulating SQL queries.</p> <p>Attackers inject specially crafted SQL code into user inputs, taking advantage of improper validation and sanitization. This can lead to unauthorized access to sensitive information and compromise the security of the application.</p> <br>  <p><strong>Risks and Impact</strong></p> <p>- <strong>Login Bypass:</strong> Exploiting SQL injection vulnerabilities can bypass authentication mechanisms, allowing unauthorized access to protected areas.</p> <p>- <strong>Data Exposure:</strong> Attackers can retrieve, modify, or delete sensitive data stored in the database, compromising data integrity and confidentiality.</p> <p>- <strong>Code Execution:</strong> In severe cases, SQL injection can lead to arbitrary code execution, giving attackers control over the application and potentially the entire server.</p> <p>- <strong>Reputation Damage:</strong> Successful SQL injection attacks can damage the reputation of the affected organization, leading to loss of trust among users and customers.</p> <br>  <p><strong>Common SQL Injection Techniques</strong></p> <p>1. <strong>Union-Based SQL Injection:</strong> Exploiting the UNION SQL operator to combine the results of the original query with those of a second query.</p> <p>2. <strong>Time-Based Blind SQL Injection:</strong> Manipulating the query to introduce delays, revealing information based on the time it takes for the application to respond.</p> <p>3. <strong>Boolean-Based Blind SQL Injection:</strong> Exploiting boolean conditions in the query to infer information about the database.</p> <br>  <p><strong>Hands-On Exercise</strong></p> <p>Get ready for a simulated login bypass exercise to understand SQL injection. Your task is to manipulate the login form to gain unauthorized access. The score of the mission will be based on the correctness of your actions, so engage your mind and proceed with caution.</p>"
            },
            "dropdowns": {
                "0": [
                    " OR '1'='1';",
                    "' AND 1=1 --",
                    "' OR 1=1 --",
                    " AND '1'='1'; --"
                ],
                "1": [
                    "SELECT * FROM users WHERE username='admin' AND password='’ OR 1=1 --';",
                    "SELECT * FROM users WHERE username='admin' AND password=' OR '1'='1'; --';",
                    "SELECT * FROM users WHERE username='admin' AND password=' AND '1'='1'; --';",
                    "SELECT * FROM users WHERE username='admin' AND password='’ AND 1=1 --';"
                ],
                "2": [
                    "arthur",
                    "admin",
                    "giacomo"
                ],
                "solutions": [
                    2,
                    0,
                    1
                ]
            },
            "text": "The exercise is to craft the post request payload for the password field:<br><br><b><code>SELECT * FROM users WHERE username='$username' AND password='$password'</code></b>;<br><br>Username: <b><code>admin</code></b><br>Password: {}<br><br> The login query processed if the attack is correct is {}<br><br>As a result, the query returns True and the user logs in as {}",
            "type": "sd",
            "explanation": "    <h2 style=\"font-weight: bold;\">Website Description:</h2>     <br>     <p>Imagine a simple login system where users can log in with their username and password: the login functionality is implemented using SQL queries to check user credentials against a database.</p>     <br>     <h2 style=\"font-weight: bold;\">Target:</h2>     <br>     <p>The goal is to bypass the login mechanism and gain unauthorized access by exploiting SQL injection vulnerabilities.</p>     <br>     <h2 style=\"font-weight: bold;\">Website Structure:</h2>     <br>     <ul>         <li><strong>Login Page:</strong> <code>http://example.com/login.php</code></li>         <li><strong>Database Connection:</strong> The login system connects to a MySQL database with a table named <code>users</code> containing columns <code>username</code> and <code>password</code>.</li>     </ul>     <br>     <h2 style=\"font-weight: bold;\">Attack Description:</h2>     <br>     <p>The login system is vulnerable to SQL injection, and the injection point is the user input fields for username and password.</p>     <br>     <p>The login query is something like:</p><br><pre><code>SELECT * FROM users<br>&emsp;&emsp;WHERE username='$username' AND password='$password';</code>     </pre>     <br>     <p>The website does not properly validate and sanitize user inputs, allowing an attacker to manipulate the SQL query.</p>     <br>     <h2 style=\"font-weight: bold;\">Craft a SQL Injection Attack:</h2>     <br>     <p>Assume that you already know a valid username (e.g., <code>admin, arthur, giacomo</code>) but you need to bypass the password check: your goal is to bypass the login and gain unauthorized access.</p>     <br>",
            "points": 50
        },
        "mission_3": {
            "difficulty": "easy",
            "solution": [
                "email",
                "border rounded px-2 py-1 text-black",
                "/html/body/form/button"
            ],
            "kind": "e2e",
            "blocks": [
                "<code>id</code> of the email field:   ",
                "",
                "<br><code>class</code> of the password field:   ",
                "",
                "<br><code>XPath</code> of the submit button:   ",
                ""
            ],
            "storyline": "python",
            "name": "HTML selectors",
            "threshold": 100,
            "learning": {
                "exerciseLink": "/exercise/3",
                "learningLink": "/learning/3",
                "resourceLink": "https://ghostinspector.com/blog/css-selector-strategies-automated-browser-testing/",
                "content": "<center><p><strong>Welcome to Mission Number 3</strong></p> <p>It's time to learn about E2E testing, are you ready?</p></center> <br> <p><strong>Understanding end-to-end testing (E2E testing)</strong></p> <p>End-to-end testing is a comprehensive software testing approach that evaluates the entire system's functionality from     start to finish. The goal of this testing method is to simulate real-world user scenarios and ensure seamless     integration among various components of a software application.</p> <p>This type of testing helps identify potential issues related to data flow, communication between components, and     overall system performance, ensuring that the software meets specified requirements and functions as intended in a     real-world environment.</p> <br> <p><strong>Locate Elements</strong></p> <p>Since E2E testing “simulates” the journey of a real user, your introduction to E2E testing starts here with the     easiest concept but the most powerful: writing code to correctly locate elements and interact with them.</p> <br> <p>Generally, you can locate web elements in a few different ways:</p> <p>- <strong>id selector:</strong> if an element has a unique id, the testing framework can directly target such id.</p> <p>- <strong>XPath</strong> the elements are targeted using their position inside the DOM tree of the website.</p> <p>- <strong>CSS selector:</strong> elements can be selected using CSS classes attributed to them.</p><br> <p><strong>Hands-On Exercise</strong></p> <p>On the next page, you will be presented with three buttons. For each one of them, you will need to correctly identify     the id, XPath, and CSS selector and input this information in the corresponding form. The score of the mission will     be based on the correctness of your actions, so     engage your mind and proceed with caution. </p>"
            },
            "text": "",
            "type": "oc",
            "explanation": "<h2 style=\"font-weight: bold;\">Website Description:</h2><br> <p>Consider the following simple login form with two fields, email and password, and a submit button.</p> <br>  <iframe srcdoc='     <html lang=\"en\">     <head>         <meta charset=\"UTF-8\">         <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">         <style>             .border { border: 1px solid #000; }             .rounded { border-radius: 5px; }         </style>     </head>     <body>         <form onSubmit=\"\" className=\"flex flex-col space-y-4\">             <div className=\"flex flex-col text-white\">                 Email: <br>                 <input className=\"border rounded px-2 py-1 text-black\" name=\"email\" type=\"email\" id=\"email\" />             </div>             <div className=\"flex flex-col text-white\">                 Password: <br>                 <input className=\"border rounded px-2 py-1 text-black\" name=\"password\" type=\"password\" id=\"password\" />             </div><br>             <button type=\"submit\" className=\"bg-tq-primary hover:bg-tq-accent text-white font-bold py-2 px-4 rounded\">                 Submit             </button>         </form>     </body>     </html> ' width=\"300\" height=\"150\"></iframe> <br><br>  <h2 style=\"font-weight: bold;\">Form Structure:</h2><br> Each element of the form: <ul style=\"list-style: circle; margin-left:3%;\">     <li>Can be identified by an <code>id</code></li>     <li>It is characterized by a <code>class</code></li>     <li>It is located in the DOM tree by an <code>XPath</code></li> </ul><br>  <p>The values of these attributes can be found with the <b>browser's developer console</b>, using the inspect function     to access the elements of this page. This function allows one to explore the HTML and CSS of a web page, finding and     modifying specific elements.</p> <br>  <h2 style=\"font-weight: bold;\">Exercise Description:</h2> <br> <p>The exercise consists of completing blanks by typing in the right solution for each of the three form elements. The     solution is a string that can be found by inspecting this page. </p> <br>",
            "points": 50
        },
        "mission_4": {
            "difficulty": "easy",
            "solution": [
                "Calculator()",
                "calculator.multiply(-3, -5)",
                "15",
                "calculator.multiply(4, -6)",
                "-24",
                "calculator.divide(-15, -3)",
                "5"
            ],
            "kind": "unit",
            "blocks": [
                "<code> from calculator import Calculator <br><br>      class TestCalculatorMultiplication: <br> &nbsp;def test_multiplication_with_positive_numbers(self): <br> &nbsp;&nbsp;calculator = </code>",
                "",
                "<br><code>&nbsp;&nbsp;output = calculator.multiply(2, 5) <br> &nbsp;&nbsp;assert output == 10 <br><br>  &nbsp;def test_multiplication_with_negative_numbers(self): <br> &nbsp;&nbsp;calculator = Calculator() <br> &nbsp;&nbsp;output =</code>",
                "",
                "<br><code>&nbsp;&nbsp;assert output ==</code>",
                "",
                "<br><br><code>&nbsp;def test_multiplication_with_negative_and_positive_number(self): <br> &nbsp;&nbsp;calculator = Calculator()  <br> &nbsp;&nbsp;output =</code>",
                "",
                "<br><code>&nbsp;&nbsp;assert output ==</code>",
                "",
                "<br><br><code>class TestCalculatorDivision: <br> &nbsp;def test_division_with_positive_numbers(self): <br> &nbsp;&nbsp;calculator = Calculator() <br> &nbsp;&nbsp;output = calculator.divide(10, 2) <br> &nbsp;&nbsp;assert output == 5 <br><br>  &nbsp;def test_division_with_negative_numbers(self): <br> &nbsp;&nbsp;calculator = Calculator() <br> &nbsp;&nbsp;output =</code>",
                "",
                "<br><code> &nbsp;&nbsp;assert output == </code>",
                "",
                "<br><br><code> &nbsp;def test_division_with_negative_and_positive_number(self): <br> &nbsp;&nbsp;calculator = Calculator() <br> &nbsp;&nbsp;output = calculator.divide(24, -6) <br> &nbsp;&nbsp;assert output == -4 <br> </code>"
            ],
            "storyline": "python",
            "name": "PyTest Calculator",
            "threshold": 100,
            "learning": {
                "exerciseLink": "/exercise/4",
                "learningLink": "/learning/4",
                "resourceLink": "https://docs.pytest.org/en/6.2.x/index.html",
                "content": "<center><p><strong>Welcome to Mission Number 4</strong></p> <p>Get ready to dive into the world of Pytest unit testing and build robust tests for a simple calculator app!</p> </center><br> <p><strong>Understanding Pytest Unit Testing</strong></p> <p>Unit testing involves testing individual units or components of a software application in isolation to verify that     they work as intended. Pytest provides a simple and scalable way to write and execute these tests, making it an     excellent choice for testing Python code.</p> <p>Pytest is a powerful testing framework for Python that makes it easy to write simple unit tests. In this mission,     we will explore how to use Pytest to ensure the accuracy and reliability of a simple calculator application.</p> <p>Pytest follows a convention-over-configuration approach, allowing you to focus on writing test cases without the     need for extensive configuration. Its modular design and rich ecosystem make it a versatile tool for various testing     scenarios, from unit tests to functional tests.</p> <p>One of the key features of Pytest is its ability to automatically discover and run tests in your project. By adhering     to naming conventions, Pytest effortlessly identifies test files and functions, providing a seamless testing experience.</p><br> <p><strong>Writing Test Cases</strong></p> <p>Now that you understand the basics of Pytest, let's move on to writing test cases for our simple calculator app.     Test cases are scenarios or conditions that ensure the proper functioning of specific features or functionalities.</p><br> <p>Here are some key concepts in writing Pytest test cases:</p> <p>- <strong>Assertions:</strong> Verify that specific conditions are met during the test execution.</p> <p>- <strong>Test Functions:</strong> Define individual tests using Python functions marked with the `def test_` prefix.</p><br> <p><strong>Hands-On Exercise</strong></p> <p>On the next page, you'll be provided with the code for a simple calculator app. Your task is to write Pytest test     cases to ensure that each operation (addition, subtraction, multiplication, division) works correctly. Pay     attention to edge cases and handle exceptions gracefully. Your mission score will be based on the accuracy and     coverage of your test cases, so put your testing skills to the test!</p>"
            },
            "text": "",
            "type": "dnd",
            "explanation": "<h2 style=\"font-weight: bold;\">Project Description:</h2><br> <p>Let's suppose we have a simple python project with structure:</p> <br>  <code>     project <br>     ├── main.py <br>     ├── requirements.txt <br>     ├── README.md <br>     └── tests <br>     &nbsp;├── test_ex1.py <br>     &nbsp;├── test_ex2.py <br>     &nbsp;├── test_ex3.py <br>     &nbsp;└── test_ex4.py <br>     </code><br>  <h2 style=\"font-weight: bold;\">Files to test:</h2><br> Let's suppose we want to write unit tests for these functions: <br><br>  <code>     # calculator.py <br><br>     class Calculator: <br>     &nbsp;def add(self, a: float, b: float) -> float:b <br>     &nbsp;return a + b <br><br>          def multiply(self, a: float, b: float) -> float: <br>     &nbsp;return a * b <br><br>          def subtract(self, a: float, b: float) -> float: <br>     &nbsp;return a - b <br><br>          def divide(self, a: float, b: float) -> float: <br>     &nbsp;if b == 0: <br>     &nbsp;&nbsp;return 0 <br>     &nbsp;return a / b     </code><br><br>  <h2 style=\"font-weight: bold;\">Exercise Description:</h2> <br> <p>Let's suppose we're building our test suite using PyTest. The exercise consists in drag and dropping the blocks in     the right position to produce a functional test suite. </p> <br>",
            "points": 50
        },
        "mission_5": {
            "difficulty": "easy",
            "solution": [
                "files.php",
                "?",
                "file=",
                "../",
                "../",
                "server/",
                "flag.txt"
            ],
            "blocks": [
                "example.com/",
                "",
                "",
                "",
                "",
                "",
                "",
                "secrets/",
                ""
            ],
            "kind": "security",
            "storyline": "python",
            "name": "Path Traversal",
            "threshold": 100,
            "learning": {
                "exerciseLink": "/exercise/5",
                "learningLink": "/learning/5",
                "resourceLink": "https://owasp.org/www-community/attacks/Path_Traversal",
                "content": "<center><p><strong>Welcome to Mission Number 5</strong></p> <p>It's time to learn, the rocket is starting...</p> </center><br>  <p><strong>Understanding Path Traversal</strong></p> <p>Path Traversal, also known as Directory Traversal, is a security vulnerability that allows an attacker to access files and directories that are outside the web root directory. This vulnerability occurs when user input is not properly sanitized and validated.</p> <br>  <p><strong>Risks and Impact</strong></p> <ul>     <li><strong>Unauthorized Access:</strong> Exploiting path traversal vulnerabilities can lead to unauthorized access to sensitive files, including configuration files, user data, or even system files.</li>     <li><strong>Data Leakage:</strong> Attackers can read and potentially modify files they shouldn’t have access to, compromising data integrity and confidentiality.</li>     <li><strong>System Compromise:</strong> In severe cases, path traversal can lead to full system compromise, enabling attackers to execute arbitrary code.</li> </ul> <br>  <p><strong>Preventing Path Traversal</strong></p> <p>To mitigate path traversal vulnerabilities, developers should:</p> <ul>     <li>- <strong>Input Validation:</strong> Validate and sanitize user input to ensure that it adheres to expected formats and does not contain malicious characters.</li>     <li>- <strong>Use Whitelists:</strong> Employ whitelists to specify valid file and directory names, limiting the scope of allowed inputs.</li>     <li>- <strong>Implement Access Controls:</strong> Enforce proper access controls to restrict users' access to only the necessary files and directories.</li> </ul> <br> <p><strong>What you need to do?</strong></p> <p>You will complete a drag and drop exercise to play with Path Traversal. The score of the mission will be evaluated checking the correctness of the drags and drop that you will perform so play with your brain.</p>"
            },
            "explanation": "<p>Suppose we have a simple website structure with the following directories:</p><br><code> <p> /<br> |-- home/<br> |&nbsp;&nbsp;|-- user1/<br> |&nbsp;&nbsp;|-- ...<br> |<br> |-- public/<br> |&nbsp;&nbsp;|-- index.html<br> |&nbsp;&nbsp;|-- about.html<br> |&nbsp;&nbsp;|-- user_uploaded_file.txt<br> |&nbsp;&nbsp;|-- ...<br> |<br> |-- server/<br> |&nbsp;&nbsp;|-- secrets/<br> |&nbsp;&nbsp;&nbsp;&nbsp;|-- flag.txt<br> |<br> |-- index.html<br> |-- about.html<br> |-- contact.html<br> |-- files.php<br> </p> </code> <br> <p><strong>Target File:</strong></p> <p>The sensitive file we want to access is located at: <strong>/server/secrets/flag.txt</strong></p> <br> <p><strong>Website Description:</strong></p> <p>The website allows users to access certain public files, serving files based on user requests, which URL might look like this: <br><code><strong>http://example.com/files.php?file=user_uploaded_file.txt</strong></code></p>",
            "type": "dnd",
            "points": 50
        },
        "mission_6": {
            "difficulty": "medium",
            "solution": [
                "6",
                "2",
                "' UNION ALL SELECT *, '42', '42', '42', '42' FROM real_data -- -"
            ],
            "kind": "security",
            "blocks": [
                "<b>Question 1</b>: How many columns does the table <code>dummy_data</code> have?&emsp;",
                "",
                "<br><br><b>Question 2</b>: How many columns does the table <code>real_data</code> have?&emsp;",
                "",
                "<br><br><b>Question 3</b>: Write the correct payload to retrieve the content of the table <code>real_data</code>.<br> <i> Padding should be something like</i>: <code>..., '42', '42', ...</code>&emsp;&emsp;",
                ""
            ],
            "storyline": "python",
            "name": "SQL Injection UNION Attacks",
            "threshold": "75",
            "learning": {
                "exerciseLink": "/exercise/6",
                "learningLink": "/learning/6",
                "resourceLink": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html",
                "content": "<center><h1 className=\"p-4 text-center\"><strong>Welcome to Mission Number 6</strong></h1>  intricate world of SQL injection UNION attacks </center><br/> <p>In this thrilling mission, you are about to embark on a journey into the intricate world of SQL injection UNION attacks.      These attacks are a notorious technique employed by cunning hackers to manipulate and extract sensitive data from a database.</p> <br> <p>Get ready to dive deep into the realm of cybersecurity as you unravel the nuances of SQL injection. The stakes are high, and your mission is to understand the intricacies of UNION attacks – a maneuver that involves injecting a SELECT statement to cunningly combine results from multiple queries.</p>  <br> <p>As you navigate through this mission, be prepared to encounter real-world scenarios where SQL injection poses a significant threat. Your objective? To not only comprehend how these attacks work but to equip yourself with the knowledge needed to thwart them. Learn the art of implementing robust input validation and master the use of parameterized queries in your applications.</p>    <br>  <p><strong>Note:</strong> A word of caution – these exercises should only be conducted in controlled environments or with explicit permission. Unauthorized SQL injection attempts on real-world websites are not only illegal but also highly unethical.</p>  <p>Prepare for an immersive experience, where the lines between attacker and defender blur, and your skills as a cybersecurity enthusiast are put to the test.</p>   <br><strong><h2>Exploring SQL Injection</h2>  </strong> <p>Before delving into UNION attacks, let's take a moment to understand the broader concept of SQL injection. It occurs when an attacker exploits vulnerabilities by injecting malicious SQL code into a query. This nefarious practice can lead to unauthorized access, data disclosure, and potential havoc.</p> <br>   <p>The key to defending against SQL injection lies in your ability to comprehend the intricacies of database interactions and fortify your applications with robust security measures.</p>  <br> <strong> <h2>The Art of Prevention</h2> </strong>  <p>Equipped with knowledge and armed with preventative measures, you will learn how to safeguard your applications against SQL injection threats. Explore the world of input validation, where every piece of data is scrutinized and validated before reaching the database.</p>   <br> <p>Parameterized queries will become your go-to weapon, allowing you to execute queries safely and securely. With these tools in your arsenal, you can confidently face the challenges posed by SQL injection and emerge victorious.</p>  <br><strong> <h3>Challenge Yourself</h3>  </strong> <p>Ready for a challenge? Test your newfound skills by navigating through simulated scenarios that mimic real-world threats.      Only by immersing yourself in these challenges can you truly master the art of defending against SQL injection.</p>   <br> <p>Stay vigilant, stay secure, and may your journey through Mission 5 be both enlightening and empowering!</p>"
            },
            "text": "<br><br> The     executed query is:<br>     <code>SELECT * FROM dummy_data WHERE id='' UNION ALL SELECT *, 3, 4, 5, 6 FROM real_data -- -</code><br><br> And it     returns:<br> <code>1, TQTS{YAY!!}, 3, 4, 5, 6</code> ",
            "type": "oc",
            "explanation": "<h2 style=\"font-weight: bold;\"> Exercise Description</h2> The database consists of a table named <code>dummy_data</code>, of which we know the existence. However, we are told that there is another table inside the database, and we want to know what’s inside it. <br><br><strong> First Step:</strong><br>Know how many columns <code>dummy_data</code> has, in order to do the UNION SQL injection.<aside style=\"background-color: #0e0d0d; border: 1px solid #c77777; padding: 10px; margin: 20px;\"> You have a     vulnerable query<br>     <code><strong>SELECT</strong> * <strong>FROM</strong> dummy_data <strong>WHERE</strong> <strong>id</strong>='<user_input>'</code><br><br>     If you input <code>1</code> it gets back:<br><code>1, dummy value1, 3, another_value1, lollo, 4</code><br><br>Considering the number of values the query has returned, answer the first question on the right side.<br></aside> <strong>Second Step</strong><br>Know name and number of columns of the target table, in order to retrieve its content later.<br> <aside style=\"background-color: #0e0d0d; border: 1px solid #c77777; padding: 10px; margin: 20px;\"> You can retrieve the name of the target table from <code>TABLE_NAME</code> inside <code>information_schema</code>, by injecting the payload:<br>     <code>' UNION ALL SELECT TABLE_NAME, '42', '42', '42', '42', '42'  FROM information_schema.tables -- -</code><br><br>     Which returns:<br> <code>real_data, 42, 42, 42, 42, 42</code><br><br> We have used a padding of random values (42), to get to the correct number of columns!! <br><br>You can now     retrieve the number of columns in <code>real_data</code> by injecting:<br>     <code>' UNION ALL SELECT COUNT(*), '42', '42', '42', '42', '42' FROM INFORMATION_SCHEMA.COLUMNS WHERE  table_name = 'real_data' -- -</code><br><br> The query returns: <code>2, 42, 42, 42, 42, 42</code><br><br> Considering the returned values, answer to the second question!<br> </aside> <strong>Third Step</strong><br>Leak the content of <code>real_data</code><br><aside style=\"background-color: #0e0d0d; border: 1px solid #c77777; padding: 10px; margin: 20px;\"> <b>Padding with <code>'42'</code></b> as we did before, using the right number of columns, we have to inject the correct payload, which will be something like: <br><br><code>' UNION ALL SELECT ||add cols + padding here|| FROM real_data -- -<br><br></code>Considering you can use <code>*</code> to retrieve the real columns, try guessing the payload on the question 3!!</aside>",
            "points": 100
        },
        "mission_7": {
            "kind": "e2e",
            "blocks": [
                "<br> <code> # Task 1: Navigate to Registration Page <br> driver.get(\"http://example.com/register\") <br><br><br># Task 2: Fill in Registration Form <br><br>driver.find_element_by_id</code>",
                "",
                "<br><br><code>driver.find_element_by_id(\"password\").send_keys(</code>",
                "",
                "<code>)<br><br>driver.find_element_by_id</code>",
                "",
                "<br><br><br><code># Task 3: Assert that the user is redirected to the login page</code><br><br>",
                ""
            ],
            "threshold": "75",
            "learning": {
                "exerciseLink": "/exercise/7",
                "learningLink": "/learning/7",
                "resourceLink": "https://www.selenium.dev/documentation/",
                "content": "    <center><strong>Welcome to Mission 7<h2 > End-to-End Testing with Selenium and Python</h2> </center><br/><p style=\"margin-bottom: 15px;\">In this exercise, we'll be utilizing Selenium with Python to conduct end-to-end testing on a web application. Our main objective is to ensure that the web application functions correctly, specifically focusing on user registration, login, and profile management functionalities.</p>          <p style=\"margin-bottom: 15px;\">To begin, let's outline the steps required to complete the exercise:</p>          <p style=\"margin-bottom: 15px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Navigate to the registration page: We'll use Selenium to instruct the web browser to open the registration page of the web application.</p>        <p style=\"margin-bottom: 15px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. Fill in the registration form: We need to provide valid information in the registration form. It's important to note that the username we choose must be unique, considering that the database already contains the username \"pippo\".</p>            <p style=\"margin-bottom: 15px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. Submit the form: After filling in the registration form, we'll submit it using Selenium.</p>            <p style=\"margin-bottom: 15px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. Verify redirection to the login page: Once the form is submitted, we'll verify that the user is redirected to the login page. This can be done by checking if the title of the page changes to \"Login\".</p>              <p style=\"margin-bottom: 15px;\">Now, let's translate these steps into code using Selenium with Python:</p>      <pre style=\"background-color: #f4f4f4; padding: 10px; border-radius: 5px; overflow-x: auto;\"> <code style=\"color: #c7254e; background-color: #f9f2f4; padding: 2px 4px; border-radius: 4px; font-size: 90%; white-space: pre-wrap;\"> # Task 1: Navigate to Registration Page<br> driver.get(\"http://example.com/register\")<br> <br> # Task 2: Fill in Registration Form<br> driver.find_element_by_id(\"username\").send_keys(\"unique_username\")<br> driver.find_element_by_id(\"password\").send_keys(\"your_password\")<br> driver.find_element_by_id(\"confirm_password\").send_keys(\"your_password\")<br> <br> # Task 3: Submit the form<br> driver.find_element_by_id(\"submit_button\").click()<br> <br> # Task 4: Verify redirection to Login Page<br> login_page_title = driver.title<br> assert login_page_title == \"Login\", \"User was not redirected to the login page\"<br> </code> </pre>"
            },
            "type": "dnd",
            "explanation": "<strong>Web Application Overview:</strong><br><br><strong>Testing Objective:</strong> <p><br>The objective of this exercise is to perform end-to-end testing using Selenium with Python to ensure         the proper functioning of the web application.<br><br> The test scenarios will cover user registration, login,         and profile management functionalities.</p><br><strong>Exercise Tasks:</strong><br> <ul>     <li>1. Navigate to the registration page <code>http://example.com/register</code></li><br>     <li>2. Fill in the registration form with valid information: unique username considering in the database there’s         already the username <code>pippo</code></li><br>     <li>3. Submit the form</li><br>     <li>4. Verify that the user is redirected to the login page: check if in the title of the page, now there’s         <code>\"Login\"</code></li><br> </ul>",
            "points": 100,
            "difficulty": "medium",
            "solution": [
                "(\"username\").send_keys(\"pippo\")",
                "-SecurePassword99",
                "(\"submit_button\").click()",
                "\"Login\" in driver.title"
            ],
            "storyline": "python",
            "name": "E2E Testing Exercise",
            "options": [
                "(\"submit_button\").click()",
                "(\"username\").send_keys(\"pippo\")",
                "(\"username\").send_keys(\"pluto\")",
                "-SecurePassword99",
                "securepassword",
                "\"Login\" in driver.title",
                "driver.title == \"Login\""
            ],
            "time": 60,
            "text": ""
        },
        "mission_8": {
            "difficulty": "medium",
            "solution": [
                false,
                false,
                true,
                true,
                true,
                false,
                true,
                false,
                false,
                true
            ],
            "selectables": [
                "20-57",
                "89-117",
                "125-150",
                "156-190",
                "263-273",
                "287-298",
                "302-307",
                "315-328",
                "341-347",
                "361-364"
            ],
            "storyline": "python",
            "name": "Semantic and Syntax Errors",
            "learning": {
                "exerciseLink": "/exercise/8",
                "learningLink": "/learning/8",
                "content": "<center><strong>Welcome to Mission Number 8 </strong><br/> Understanding Semantic and Syntax Bugs.</center><br> <p>     Semantic and Syntax bugs are common issues encountered during software development. It's crucial to distinguish between them to effectively debug and maintain code. </p> <br><strong>Semantic Bugs</strong> <p>     Semantic bugs occur when the logic of the program is flawed, leading to unexpected behavior. These bugs may not result in syntax errors but can cause incorrect program output or undesired outcomes. Semantic bugs are often harder to detect than syntax bugs because they involve understanding the intended functionality of the code. Examples of semantic bugs include miscalculations, incorrect conditional statements, and improper data handling. </p> <br><strong>Syntax Bugs</strong> <p>     Syntax bugs, on the other hand, are errors in the structure or grammar of the code. These bugs violate the rules of the programming language, causing the interpreter or compiler to raise errors. Syntax bugs are usually easier to identify and fix compared to semantic bugs because they are detected by the compiler or interpreter during the code compilation or execution process. Common syntax bugs include missing semicolons, mismatched parentheses, and misspelled keywords. </p> <br><strong>Risks and Impact</strong> <p>     Semantic bugs can have significant consequences, such as incorrect computation results, security vulnerabilities, or system crashes. These bugs can lead to data corruption, loss of user trust, and financial losses for organizations. Syntax bugs typically prevent the code from executing altogether, resulting in immediate errors during compilation or runtime. While less severe than semantic bugs, syntax bugs can still disrupt development workflow and delay project timelines. </p> <br><strong>Preventing and Resolving Bugs</strong> <p>     To prevent semantic bugs, developers should thoroughly understand the requirements and specifications of the software and conduct rigorous testing. Code reviews, unit testing, and integration testing are essential for identifying and addressing semantic bugs early in the development lifecycle. Debugging semantic bugs involves analyzing the program's behavior, identifying discrepancies between expected and actual outcomes, and implementing corrective measures. </p> <p>     Syntax bugs can be avoided by adhering to the syntax rules of the programming language, using linting tools, and paying attention to compiler or interpreter error messages. Code editors with syntax highlighting and auto-completion features can also help prevent syntax errors during development. Debugging syntax bugs involves analyzing the code for syntax errors indicated by error messages and correcting them accordingly using code editors or integrated development environments (IDEs). </p> <br><strong>What you need to do?</strong> <p>     You will complete an exercise to spot semantic and syntax bugs in a given code snippet. Pay close attention to the logic and structure of the code to identify and correct the bugs effectively. Your ability to distinguish between semantic and syntax bugs will be crucial for successful debugging and improving your programming skills. </p>",
                "resouceLink": "https://www.honeybadger.io/blog/beginners-guide-to-software-testing-in-python/"
            },
            "threshold": 75,
            "text": "\nclass Student:\n    def __init__(self, name, exam_marks):\n       self.name = name\n       self.exam_marks = exam_marks\n       self.calc = Calculater()\n\n\n    def calculate_average_score(self))\n       total_score = 0\n       idx = 0\n       for idx, mark in enumerate(exam_marks):\n           total_score += marks\n       average_score = self.calc.divide(total_score, idx)\n       return average_score\n\n       \nexam_scores = [25, 30, 30, 22]\nstudent1 = Student(\"Alice\", exam_scores)\naverage_score = student1.calculate_average_score()\n\nprint(f\"{student1.name}'s average score is: {average_score}\")",
            "type": "debug",
            "explanation": "    <h1>You have a class of functions from a calculator:</h1><br><pre><code>class Calculator:<br>     def __init__(self):<br>         self.result = None<br> <br>     def add(self, a, b):<br>         self.result = a + b<br>         return self.result<br> <br>     def subtract(self, a, b):<br>         self.result = a - b<br>         return self.result<br> <br>     def multiply(self, a, b):<br>         self.result = a * b<br>         return self.result<br> <br>     def divide(self, a, b):<br>         if b == 0:<br>             raise ValueError(\"Division by zero is not allowed.\")<br>         self.result = a / b<br>         return self.result<br>         </code>     </pre><p>Consider the class <code>Student</code> on the right, which is importing and using the <code>Calculator</code> class to compute the average of the marks of exams of a student.  Your goal is to spot bugs in the code.</p>",
            "points": 100
        },
        "mission_9": {
            "difficulty": "medium",
            "solution": [
                "@pytest.fixture",
                "before_module",
                "@pytest.mark.parametrize",
                "before_all",
                "after_class",
                "autouse",
                "after_all",
                "scope"
            ],
            "kind": "unit",
            "blocks": [
                "A. We define it with different scopes (function, class,…) to perform setup and teardown actions.",
                "B. Runs once before all test functions in the test module.",
                "C. Used as a decorator to create a parameterized test with multiple test cases for various arithmetic operations.",
                "D. Runs once before every test function in the test module.",
                "E. Runs after every test class in the test module.",
                "F. When it is true then the fixture will be invoked automatically before each test that depends on it.",
                "G. Runs once after all test functions in the test module.",
                "H. it determines the area in which the fixture is executed, controlling the fixture setup and teardown actions are performed"
            ],
            "storyline": "python",
            "name": "Calculator with Parametrized Unit Testing",
            "options": [
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8"
            ],
            "threshold": "75",
            "learning": {
                "exerciseLink": "/exercise/9",
                "learningLink": "/learning/9",
                "resourceLink": "https://reflectoring.io/tutorial-junit5-parameterized-tests/",
                "content": "<center><h2><strong> Welcome to Mission 9</strong></h2>Learn parameterize testing </center><br/> <p style=\"font-family: Arial, sans-serif; line-height: 1.6; margin-bottom: 15px;\"><strong>Parameterized Tests:</strong></p> <ul style=\"margin-bottom: 15px;\">   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Parameterized tests allow you to run the same test function with different sets of parameters.</li>   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- They are created using <code>@pytest.mark.parametrize</code> decorator, which defines multiple test cases for various operations.</li> </ul>  <p style=\"font-family: Arial, sans-serif; line-height: 1.6; margin-bottom: 15px;\"><strong>PyTest Fixtures:</strong></p> <ul style=\"margin-bottom: 15px;\">      <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Fixtures are functions that provide data, setup, or other resources to tests.</li>      <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Fixtures are functions that provide data, setup, or other resources to tests.</li>      <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- They can be applied with different scopes (<code>function</code>, <code>class</code>, <code>module</code>, <code>session</code>) to control when they are executed.</li>      <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- They can be applied with different scopes (<code>function</code>, <code>class</code>, <code>module</code>, <code>session</code>) to control when they are executed.</li>      <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Fixtures are defined using <code>@pytest.fixture</code> decorator.</li>      <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Fixtures are defined using <code>@pytest.fixture</code> decorator.</li>      <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- The <code>autouse</code> parameter in fixtures determines whether the fixture will be automatically used by all tests without explicit usage.</li>      <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- The <code>autouse</code> parameter in fixtures determines whether the fixture will be automatically used by all tests without explicit usage.</li> </ul> </ul>  <p style=\"font-family: Arial, sans-serif; line-height: 1.6; margin-bottom: 15px;\"><strong>Fixture Behaviors:</strong></p> <ul style=\"margin-bottom: 15px;\">   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- before_module:</strong> Runs once before every test module, setting up the module-level environment.</li>   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- after_class:</strong> Runs after every test class in the module, performing cleanup actions.</li>   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- before_all:</strong> Runs once before all test functions in the module, setting up global environment.</li>   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- after_all:</strong> Runs once after all test functions in the module, cleaning up global environment.</li>   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- @pytest.fixture:</strong> Defines fixtures with different scopes for setup and teardown actions.</li>   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- @pytest.mark.parametrize:</strong> Defines parameterized tests with multiple test cases for various operations.</li>   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- autouse:</strong> Automatically invokes the fixture before each test that depends on it.</li>   <li style=\"font-family: Arial, sans-serif; line-height: 1.6;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- scope:</strong> Determines the area in which the fixture is executed, controlling fixture setup and teardown actions.</li> </ul>"
            },
            "type": "mm",
            "explanation": " <p style=\"font-family: Arial, sans-serif; line-height: 1.6; margin-bottom: 20px;\"><strong>Instructions:</strong><br> Match each PyTest fixture with its corresponding behavior in the test setup and teardown process.</p>  <p style=\"font-family: Arial, sans-serif; line-height: 1.6; margin-bottom: 20px;\">Consider the following code:</p>  <pre style=\"font-family: Arial, monospace; background-color: #0e0d0d; padding: 10px; border-radius: 5px; overflow-x: auto; margin-bottom: 20px;\"> <code> import pytest <br> class Calculator:<br>     def __init__(self):<br>         self.result = None<br>         <br>     def add(self, a, b):<br>         self.result = a + b<br>         return self.result<br>         <br>     def subtract(self, a, b):<br>         self.result = a - b<br>         return self.result<br>         <br>     def multiply(self, a, b):<br>         self.result = a * b<br>         return self.result<br>         <br>     def divide(self, a, b):<br>         if b == 0:<br>             raise ValueError(\"Division by zero is not allowed.\")<br>         self.result = a / b<br>         return self.result<br>         <br> @pytest.fixture(scope=\"session\", autouse=True)<br> def before_all():<br>     print(\"\\nBefore all tests (session scope)\")<br>     <br> @pytest.fixture(scope=\"module\")<br> def before_module():<br>     print(\"\\nBefore each module\")<br> <br> @pytest.fixture(scope=\"class\")<br> def before_class():<br>     print(\"Before each class\")<br>     <br> @pytest.fixture(scope=\"function\")<br> def before_each():<br>     print(\"Before each test\")<br>     <br> @pytest.fixture(scope=\"function\")<br> def after_each():<br>     print(\"After each test\")<br>     <br> @pytest.fixture(scope=\"class\")<br> def after_class():<br>     print(\"After each class\")<br>     <br> @pytest.fixture(scope=\"module\")<br> def after_module():<br>     print(\"\\nAfter each module\")<br>     <br> @pytest.fixture(scope=\"session\", autouse=True)<br> def after_all():<br>     print(\"\\nAfter all tests (session scope)\")<br>     <br> @pytest.mark.parametrize(\"a, b, expected\", [<br>     (2, 3, 5),   # Addition<br>     (5, 3, 2),   # Subtraction<br>     (4, 6, 24),  # Multiplication<br>     (8, 2, 4),   # Division<br> ])<br> def test_calculator_operations(a, b, expected, before_module, before_class, before_each, after_each):<br>     calculator = Calculator()<br>     result = calculator.add(a, b) if a + b == expected else \\<br>              calculator.subtract(a, b) if a - b == expected else \\<br>              calculator.multiply(a, b) if a * b == expected else \\<br>              calculator.divide(a, b) if a / b == expected else None<br>     assert result == expected, f\"Expected result {expected}, but got {result}\"<br> </code> </pre>",
            "points": "100"
        }
    }
}